<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bitcoin y Criptomonedas</title>
    <description>Mis opiniones e investigaciones acerca del mundo de Bitcoin, Blockchain y criptomonedas que serán el futuro de la Internet del dinero</description>
    <link>https://leonardo384.github.io/</link>
    <atom:link href="https://leonardo384.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 08 Jan 2019 18:59:06 -0500</pubDate>
    <lastBuildDate>Tue, 08 Jan 2019 18:59:06 -0500</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Documentación Técnica de Ethereum</title>
        <description>&lt;p&gt;La intención de Ethereum es crear un protocolo alternativo para desarrollar aplicaciones descentralizadas
al introducir un conjunto nuevo de aspectos que creemos serán de gran uso en una clase extensa de aplicaciones descentralizadas, sobretodo en situaciones
donde importan el tiempo de desarrollo, la seguridad para aplicaciones pequeñas y poco usadas,
y la capacidad de interacción eficiente de diferentes aplicaciones. Ethereum logra esto construyendo lo que esencialmente es la mayor capa fundamental abstracta: un blockchain con un lenguaje Turing completo incorporado que le permite a cualquiera escribir contratos inteligentes y aplicaciones
descentralizadas donde se pueden crear reglas propias y arbitrarias de propiedad, formatos de transacción y funciones de transición de estado.
Se puede escribir una versión esencial de Namecoin en solo dos líneas de código y otros protocolos tales como divisas y sistemas de reputación en menos de veinte líneas.
También se pueden crear sobre la plataforma contratos inteligentes que son especies de  “cajas” criptográficas que contienen un valor y lo revelan solo si se cumplen ciertas condiciones.
Éstas tienen mucho más poder que las que ofrece el código de Bitcoin debido a las capacidades agregadas de la completitud de Turing, el reconocimiento del valor, del blockchain y del estado.&lt;/p&gt;

&lt;h3 id=&quot;filosofa&quot;&gt;Filosofía&lt;/h3&gt;

&lt;p&gt;El diseño detrás de Ethereum debe seguir los siguientes principios:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Simplicidad&lt;/strong&gt;: el protocolo Ethereum debe ser tan simple como sea posible, incluso sacrificando el amacenamiento de datos y la eficiencia de tiempo. Un programador promedio
debería ser capaz de seguir e implementar una especificación completa, dándose cuenta del potencial sin precedentes de democratización que las criptomonedas traen y extendiendo la visión
de Ethereum como un protocolo abierto a todos. Ninguna optimización que agregue complejidad se debería incluir a menos que esa optimización brinde beneficios considerables.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Universalidad&lt;/strong&gt;: una parte fundamental de la filosofía de diseño es que Ethereum no tiene “características”.
En vez de eso, Ethereum trae un lenguaje interno de codificación Turing completo que un programador puede usar
para crear cualquier contrato inteligente o tipo de transacción que puede ser definido matemáticamente.
¿Quiere crear su propio producto financiero? Con Ethereum se puede. ¿Quiere crear su propia moneda? Desarróllelo como un contrato en Ethereum. ¿Quiere montar un script de ejecución constante o Skynet completo?
Podría necesitar tener varios miles de contratos interconectados y asegurarse de llenarlos de información, pero también se puede en Ethereum.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Modularidad&lt;/strong&gt;: las partes del protocolo Ethereum deben ser diseñados para ser tan modulares y separables como sea posible.
Durante la fase de desarrollo, nuestro objetivo es crear un programa en donde si se necesita hacer una pequeña modificación del protocolo en un lugar, el stack de la aplicación
seguirá funcionando sin más cambios. Las innovaciones como Ethash, los árboles modificados de Patricia y RLP (Recursive Length Prefix)
deberían y son implementados como bibliotecas separadas y completas. Este es el procedimiento para que ciertas características disponibles en Ethereum se puedan transferir a otros protocolos, incluso si Ethereum no las aplica. El desarrollo en Ethereum debería ser para beneficiar lo más posible al ecosistema de criptomonedas en general y no solo a Ethereum.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Agilidad&lt;/strong&gt;: los detalles del protocolo Ethereum no son inflexibles. Aunque seremos extremadamente cuidadosos al modificar estructuras de alto nivel.
Un ejemplo es la hoja de ruta de partición (sharding roadmap) donde se abstrae la ejecución dependiendo de la disponibilidad de datos que cumplan con el consenso.
Los tests computacionales posteriores en el proceso de desarrollo nos pueden llevar a descubrir que ciertas modificaciones, por ejemplo, al protocolo de arquitectura de la Máquina Virtual de Ethereum (EVM), van a mejorar la escalabilidad o la seguridad. Si esas ocasiones se presentan, las vamos a aprovechar.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;No discriminación&lt;/strong&gt; y &lt;strong&gt;no censura&lt;/strong&gt;: el protocolo no debería tratar de restringir o prevenir categorías específicas de uso. Todos los mecanismos regulatorios en el protocolo deberían ser diseñados para regular directamente el daño y no tratar de oponerse a aplicaciones específicas no deseadas. Un programador puede incluso ejecutar un bucle infinito encima de Ethereum mientras esté dispuesto a seguir pagando el costo de la transacción de cada instrucción de cómputo.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;las-cuentas-de-ethereum&quot;&gt;Las cuentas de Ethereum&lt;/h3&gt;

&lt;p&gt;En Ethereum el estado se compone de objetos llamados “cuentas” cada una con una dirección de 20 bytes y con estados de transición que representan transferencias directas de valor e información entre cuentas. Una cuenta de Ethereum contiene cuatro campos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;El número único (nonce) que se usa para asegurarse de que cada transacción se pueda procesar solo una vez.&lt;/li&gt;
  &lt;li&gt;El balance actual de ether de la cuenta&lt;/li&gt;
  &lt;li&gt;El código de contrato de la cuenta si existe&lt;/li&gt;
  &lt;li&gt;El almacenamiento de la cuenta (vacío por defecto)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;“Ether” es el principal criptocombustible de Ethereum y se usa para pagar costos de transacción. En general, hay dos tipos de cuentas: &lt;strong&gt;cuentas de propiedad externa&lt;/strong&gt;, controladas por claves privadas y &lt;strong&gt;cuentas de contrato&lt;/strong&gt; controladas por código de contrato. Una cuenta de propiedad externa no tiene código y se pueden enviar mensajes desde una de estas cuentas creando y firmando una transacción; en una cuenta de contrato, cada vez que se recibe un mensaje, el código se activa, lo que permite leer y escribir al almacenamiento interno y enviar otros mensajes o crear contratos a su vez.&lt;/p&gt;

&lt;p&gt;Nótese que los “contratos” en Ethereum no deben verse como algo que debe ser “ejecutado” o “cumplido”; son más bien como “agentes autónomos” que viven dentro del ambiente de ejecución de Ethereum y siempre están ejecutando un segmento específico de código cuando son “despertados” por un mensaje o una transacción y además tienen control directo sobre su propio balance de ether y tienen su propio almacenamiento tipo clave/valor para registrar variables persistentes.&lt;/p&gt;

&lt;h3 id=&quot;mensajes-y-transacciones&quot;&gt;Mensajes y Transacciones&lt;/h3&gt;

&lt;p&gt;El término “transacción” se usa en Ethereum para referirse a un paquede de datos firmado que guarda un mensaje que se va a enviar a una cuenta de propiedad externa. Las transacciones contienen:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;El destinatario del mensaje&lt;/li&gt;
  &lt;li&gt;Una firma que identifica al remitente&lt;/li&gt;
  &lt;li&gt;La cantidad de ether que se transfiere de remitente a destinatario&lt;/li&gt;
  &lt;li&gt;Un campo de datos opcional&lt;/li&gt;
  &lt;li&gt;un valor STARTGAS que representa el número máximo de instrucciones computacionales que la ejecución de la transacción tiene permitido hacer&lt;/li&gt;
  &lt;li&gt;Un valor GASPRICE que representa pago que el remitente hace por cada instrucción computacional&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los primeros tres son campos estándar que se esperan en cualquier criptomoneda. El campo de datos no tiene una función por defecto, pero la máquina virtual tiene un código de operación que un contrato puede usar para acceder a los datos. Como un ejemplo de caso de uso, si un contrato está funcionando como servicio de registro de dominios basado en blockchain, entonces podría interpretar los datos que está recibiendo como compuestos de dos campos: el primer campo es el dominio que hay que registrar y el segundo campo es la dirección IP a la que hay que asociar. El contrato leería estos valores desde los datos del mensaje y los guardaría apropiadamente en el almacenamiento.&lt;/p&gt;

&lt;p&gt;Los campos STARTGAS y GASPRICE son cruciales para el modelo antinegación de servicio (DDoS). de Ethereum. Para evitar bucles infinitos accidentales u hostiles o cualquier otro  desperdicio computacional en código, cada transacción necesita establecer un límite acerca de cuantas instrucciones computacionales de ejecución de código puede utilizar. La unidad fundamental de computación es el “gas”; generalmente una instrucción computacional cuasta 1 gas aunque ciertas operaciones tiene un mayor costo por ser más intensas computacionalmente o porque aumentan la cantidad de datos que debe ser almacenado como parte del estado. También hay un pago de 5 gas para cada byte en los datos de transacción. La intención del sistema de pagos es para exigir a un atacante que pague proporcionalmente a cada recurso que consume incuido computacón, ancho de banda y almacenamiento. De esta forma, cualquier transacción que lleve al consumo de una mayor cantidad de cualquiera de estos recursos debe pagar una comisión en gas justamente proporcional al ese incremento&lt;/p&gt;

&lt;h3 id=&quot;mensajes&quot;&gt;Mensajes&lt;/h3&gt;

&lt;p&gt;Los contratos tienen la capacidad de enviar “mensajes” a otros contratos. Los mensajes son objetos virtuales que nunca se serializan y solo existen en el ambiente de ejecución de Ethereum. Un mensaje contiene:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;El remitente del mensaje (implícito)&lt;/li&gt;
  &lt;li&gt;El destinatario del mensaje&lt;/li&gt;
  &lt;li&gt;La cantidad de ether para transferir junto con el mensaje&lt;/li&gt;
  &lt;li&gt;Un campo de datos opcional&lt;/li&gt;
  &lt;li&gt;Un valor de STARTGAS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Básicamente un mensaje es como una transición, excepto que es producido por un contrato y no un actor central. Un mensaje se produce cuando el código actual en ejecución del contrato llama al código operacional &lt;code class=&quot;highlighter-rouge&quot;&gt;CALL&lt;/code&gt; el cual crea y ejecuta un mensaje. Al igual que en una transacción, un mensaje causa que la cuenta del remitente ejecute su código. Así, los contratos pueden relacionarse con otros contratos de la misma forma que los actores externos lo hacen.&lt;/p&gt;

&lt;h3 id=&quot;la-funcin-de-transicin-de-estado-de-ethereum&quot;&gt;La Función de Transición de Estado de Ethereum&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/ethertransition.png&quot; alt=&quot;funcion de transicion estado de etehereum&quot; /&gt;&lt;/p&gt;

&lt;p&gt;La función de transición de estado de Ethereum, &lt;code class=&quot;highlighter-rouge&quot;&gt;APPLY(S, TX) -&amp;gt; S&#39;&lt;/code&gt; se puede definir así:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Revisa si la transacción está bien formada (es decir, tiene el número correcto de valores), si la firma es válida y el nonce corresponde al nonce en la cuenta del remitente. De otra forma, devuelve un error.&lt;/li&gt;
  &lt;li&gt;Calcula la comisión de la transacción como &lt;code class=&quot;highlighter-rouge&quot;&gt;STARTGAS * GASPRICE&lt;/code&gt;, y determina la dirección de remisión a partir de la firma. Sustrae la comisión desde el balance de la cuenta del remitente y aumenta el nonce del remitente. Si no hay balance suficiente para gastar, devuelve un error.&lt;/li&gt;
  &lt;li&gt;Inicia &lt;code class=&quot;highlighter-rouge&quot;&gt;GAS = STARTGAS&lt;/code&gt; y retira cierta cantidad de gas por byte para pagar los bytes de la transacción.&lt;/li&gt;
  &lt;li&gt;Transfiere el valor de la transacción desde la cuenta del remitente a la cuenta del destinatario. Si la cuenta del destinatario no existe todavía, la crea. Si la cuenta del destinatario es un contrato, ejecuta el código del contrato hasta completarlo o hasta que la ejecución consuma todo el gas.&lt;/li&gt;
  &lt;li&gt;Si transferencia de valor falla porque el remitente carecía de suficiente dinero o porque la ejecución del código consumió todo el gas, revierte todos los cambios en el estado excepto el pago de las comisiones y agrega las comisiones a la cuenta del minero.&lt;/li&gt;
  &lt;li&gt;De otra forma, reembolsa las comisiones correspondientes a los gas que sobraron al remitente y envia las comisiones de los gas consumidos al minero.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Por ejemplo, supongamos que el código del contrato es:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-serpent&quot; data-lang=&quot;serpent&quot;&gt;if !self.storage[calldataload(0)]:
    self.storage[calldataload(0)] = calldataload(32)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Hay que anotar que en realidad el código del contrato está escrito en código de EVM de bajo nivel; el ejemplo mostrado está escrito en Serpent, uno de nuestros lenguajes de alto nivel, a modo de ilustración, y pude ser compilado a código EVM. Suponga que el almacenamiento del contrato inicia vacío y se envía una transacción con un valor de 10 ether, 2000 gas, 0.0001 ether de gasprice y 64 bytes de datos con los bytes 0-31 que representan el número &lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt; y los bytes 32-63 que corresponden a la cadena &lt;code class=&quot;highlighter-rouge&quot;&gt;CHARLIE&lt;/code&gt;. El proceso para la función de transición de estado es como sigue:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Revisa que la transacción es válida y bien formada.&lt;/li&gt;
  &lt;li&gt;Revisa que el remitente de la transacción posee por lo menos 2000 * 0.001 ether. Si es así, sustrae 2 ether de la cuenta del remitente.&lt;/li&gt;
  &lt;li&gt;Inicializa gas = 2000; al asumir que la transacción es de 170 bytes y que la comisión por byte es de 5, resta 850 de modo que quedan 1150 gas.&lt;/li&gt;
  &lt;li&gt;Retira 10 ether más de la cuenta del remitente y los agrega a la cuenta del contrato.&lt;/li&gt;
  &lt;li&gt;Ejecuta el código. En este caso, es muy simple: revisa si se usa el almacenamiento del contrato en el índice 2, nota que no es así, así que asigna al almacenamiento en el índice 2 el valor &lt;code class=&quot;highlighter-rouge&quot;&gt;CHARLIE&lt;/code&gt;. Suponga que esto toma 187 gas. El resto del gas es 1150 - 187 = 963.&lt;/li&gt;
  &lt;li&gt;Regresa 963*0.001 ether a la cuenta del remitente y devuelve el estado resultante.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Nótese que los mensajes funcionan de forma equivalente a transacciones en términos de capacidad de revertir: si la ejecución de un mensaje agota el gas, entonces esa ejecución y todas las ejecuciones desencadenadas por ella se revierten, pero las ejecucuines anteriores no tienen por que hacer esto. Esto quiere decir que es “seguro” para un contrato llamar a otro contrato debido a que si A invoca a B con G cantidad de gas, entonces se garantiza que la ejecución de A pierde a lo mucho G gas. Finalmente, nótese que hay un código operacional, &lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE&lt;/code&gt;, que que crea un contrato; la mecánica de su ejecución es generalemnte similar a &lt;code class=&quot;highlighter-rouge&quot;&gt;CALL&lt;/code&gt; con la excepción de que la salida de la ejecución determina el código de un contrato recién creado.&lt;/p&gt;

&lt;h3 id=&quot;ejecucin-de-cdigo&quot;&gt;Ejecución de Código&lt;/h3&gt;

&lt;p&gt;El código en los contratos Ethereum está escrito en un lenguaje bytecode de bajo nivel basado en stacks, conocido como “código de máquina virtual de Ethereum” o “código EVM”. El código compone de una serie de bytes donde cada byte representa una operación. En general, la ejecución de código es un bucle infinito que consiste en llevar a cabo de forma repetitiva la operación en el contador actual del programa (que comienza en cero) y luego incrementando este contador unitariamente hasta alcanzar el final del código o hasta detectar una instrucción &lt;code class=&quot;highlighter-rouge&quot;&gt;STOP&lt;/code&gt; o &lt;code class=&quot;highlighter-rouge&quot;&gt;RETURN&lt;/code&gt;. Las operaciones tienen acceso a a tres tipos de espacio en donde almacenar los datos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;El &lt;strong&gt;stack&lt;/strong&gt;, un contenedor de tipo entra-último-sale-primero donde se ingresan y se retiran los valores&lt;/li&gt;
  &lt;li&gt;La &lt;strong&gt;memoria&lt;/strong&gt;, una arreglo de bytes que se puede expandir infinitamente&lt;/li&gt;
  &lt;li&gt;El &lt;strong&gt;almacenamiento&lt;/strong&gt; a largo plazo del contrato de tipo clave/valor. A diferencia del stack y la memoria que se reinician cuando se termina el cálculo, el almacenamiento persiste a largo plazo.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;El código pude acceder al valor, remitente y datos del mensaje entrante, al igual que a los datos de la cabecera del bloque, y el código puede también retornar un arreglo de bytes de datos como salida.&lt;/p&gt;

&lt;p&gt;El modelo de ejecución formal del código EVM es sorprendentemente simple. Mientras la máquina virtual Ethereum está corriendo, su estado computacional completo se puede definir por la tupla &lt;code class=&quot;highlighter-rouge&quot;&gt;(block_state, transaction, message, code, memory, stack, pc, gas)&lt;/code&gt;; aquí &lt;code class=&quot;highlighter-rouge&quot;&gt;block_state&lt;/code&gt; es el estado global que contiene todas las cuentas, incluyendo los balances y el almacenamiento. Al comienzo de cada ronda de ejecución, la instrucción actual se encuentra tomando el byte &lt;code class=&quot;highlighter-rouge&quot;&gt;pc&lt;/code&gt;-ésimo del &lt;code class=&quot;highlighter-rouge&quot;&gt;code&lt;/code&gt; (ó 0 si &lt;code class=&quot;highlighter-rouge&quot;&gt;pc &amp;gt;= len(code)&lt;/code&gt;), y cada instrucción tiene su propia definición de acuerdo a su efecto en la tupla. Por ejemplo, &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD&lt;/code&gt; retira dos elementos del stack e ingresa su suma, reduce el &lt;code class=&quot;highlighter-rouge&quot;&gt;gas&lt;/code&gt; en una unidad e incrementa &lt;code class=&quot;highlighter-rouge&quot;&gt;pc&lt;/code&gt; en una unidad, luego &lt;code class=&quot;highlighter-rouge&quot;&gt;SSTORE&lt;/code&gt; retira dos elementos del stack e inserta el segundo objeto en el almacenamiento del contrato en el índice especificado por el primer objeto. Aunque hay muchas formas de optimizar la ejecución de la máquina virtual de Ethereum a través de compilación &lt;em&gt;just-in-time&lt;/em&gt;, se puede hacer una implementación básica de Ethereum en unos cuantos cientos de líneas de código.&lt;/p&gt;

&lt;h3 id=&quot;blockchain-y-minera&quot;&gt;Blockchain y Minería&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/apply_block_diagram.png&quot; alt=&quot;diagrama de bloques&quot; /&gt;&lt;/p&gt;

&lt;p&gt;El blockchain de Ethereum es en esencia muy similar al de Bitcoin, aunque tiene algunas diferencias. La principal diferencia entre Ethereum y Bitcoin con respecto a la arquitectura blockchain es que a diferencia de Bitcoin (que sólo contiene una copia de la lista de transacciones), los bloques de Ethereum contienen una copia tanto de la lista de transacciones como del estado más reciente. Aparte de eso, otros dos valores, el número del bloque y la dificultad, también se almacenan en el bloque. El algoritmo básico de validación de Ethereum es así:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Revisar si el bloque previo referenciado existe y es válido.&lt;/li&gt;
  &lt;li&gt;Revisar que la marca cronológica del bloque es mayor que la del bloque previo referenciado y menor que 15 minutos en el futuro.&lt;/li&gt;
  &lt;li&gt;Revisar que el número del bloque, la dificultad, la raíz de la transacción, la raíz “tío” y el límite de gas (conceptos de bajo nivel específicos a Ethereum) son válidos.&lt;/li&gt;
  &lt;li&gt;Revisar que la prueba de trabajo en el bloque es válido.&lt;/li&gt;
  &lt;li&gt;Asignar a &lt;code class=&quot;highlighter-rouge&quot;&gt;S[0]&lt;/code&gt; el estado al final del bloque anterior.&lt;/li&gt;
  &lt;li&gt;Asignar a &lt;code class=&quot;highlighter-rouge&quot;&gt;TX&lt;/code&gt; la lista de transacciones del bloque, con &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; transacciones. Para todo &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; en &lt;code class=&quot;highlighter-rouge&quot;&gt;0...n-1&lt;/code&gt;, establecer &lt;code class=&quot;highlighter-rouge&quot;&gt;S[i+1] = APPLY(S[i], TX[i])&lt;/code&gt;. Si alguna aplicación retorna un error, o si el gas total consumido en el bloque hasta este punto excede el &lt;code class=&quot;highlighter-rouge&quot;&gt;GASLIMIT&lt;/code&gt;, retornar un error.&lt;/li&gt;
  &lt;li&gt;Asignar a &lt;code class=&quot;highlighter-rouge&quot;&gt;S_FINAL&lt;/code&gt; el valor de &lt;code class=&quot;highlighter-rouge&quot;&gt;S[n]&lt;/code&gt; pero agregando la recompensa del bloque al minero.&lt;/li&gt;
  &lt;li&gt;Revisar si la raíz del árbol de Merkle del estado &lt;code class=&quot;highlighter-rouge&quot;&gt;S_FINAL&lt;/code&gt; es igual a la raíz del estado final que aparece en la cabecera del bloque. Si es así, el bloque es válido; de otra forma, no es válido.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 05 Jan 2019 00:00:00 -0500</pubDate>
        <link>https://leonardo384.github.io/criptomonedas/2019/01/05/documentacion-tecnica-de-ethereum/</link>
        <guid isPermaLink="true">https://leonardo384.github.io/criptomonedas/2019/01/05/documentacion-tecnica-de-ethereum/</guid>
        
        
        <category>criptomonedas</category>
        
      </item>
    
      <item>
        <title>Las funciones hash criptográficas</title>
        <description>&lt;p&gt;Basado en el curso en Youtube “Bitcoin y Tecnología de Criptomonedas” de &lt;a href=&quot;https://www.youtube.com/channel/UCNcSSleedtfyDuhBvOQzFzQ/videos&quot;&gt;Princeton&lt;/a&gt;,
y en el libro “Bitcoin and Cryptocurrency Technologies” &lt;a href=&quot;http://bitcoinbook.cs.princeton.edu&quot;&gt;http://bitcoinbook.cs.princeton.edu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Una función hash convierte cadenas de texto arbitrarias en una salida de longitud fija de una manera determinística, pública y aleatoria.
Las funciones hash tienen tres atributos principales:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Toman un texto como entrada&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Producen una salida de tamaño fijo (256 bits)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Se calculan de forma eficiente, en un tiempo razonable&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A su vez tienen tres propiedades de seguridad:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Son libres de colisiones&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ocultan información&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Son casi imposibles de desencriptar&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;libres-de-colisiones&quot;&gt;1. Libres de colisiones&lt;/h3&gt;

&lt;p class=&quot;marco-de-foto&quot;&gt;&lt;img src=&quot;/images/libre-colisiones.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Las colisiones sí existen pero son muy difíciles de encontrar. Para hallar una habría que
probar &lt;script type=&quot;math/tex&quot;&gt;2^{130}&lt;/script&gt; entradas escogidas al azar. En ese caso hay un 99.8% de posibilidades de que dos de ellas colisionen.
El punto a destacar aquí es que tomaría tanto tiempo y poder de cómputo que esto se considera prácticamente inviable.&lt;/p&gt;

&lt;p&gt;Si asumimos que la función hash es libre de colisiones, entonces la podemos usar como un compresor de mensajes.
Si sabemos que &lt;script type=&quot;math/tex&quot;&gt;H(x)=H(y)&lt;/script&gt;, entonces es seguro asumir que &lt;script type=&quot;math/tex&quot;&gt;x = y&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Un ejemplo de aplicación de esta idea sería la comprobación de que dos archivos son iguales. Si los archivos son muy grandes podría ser difícil comprobar si son iguales.
Sin embargo, si se aplica un hash a cada archivo y se obtiene el mismo valor, podemos asegurar que se trata del mismo archivo.&lt;/p&gt;

&lt;h3 id=&quot;ocultamiento&quot;&gt;2. Ocultamiento&lt;/h3&gt;

&lt;p&gt;La propiedad de ocultamiento se puede plantear así:&lt;/p&gt;

&lt;p&gt;Dado &lt;script type=&quot;math/tex&quot;&gt;H(x)&lt;/script&gt;, es inviable encontrar &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Para que esta propiedad se cumpla, necesitamos lo siguiente: si &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt; se escoge de una distribución de probabilidad que tiene alta entropía de Renyi (entropía min), entonces dado &lt;script type=&quot;math/tex&quot;&gt;H(r|x)&lt;/script&gt; (dos entradas concatenadas), es inviable encontrar &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;.
La alta entropía de Renyi indica que la distribución está muy dispersa, de modo que ningún valor en particular puede ser escogido con más que una probabilidad despreciable.
Entonces podemos decir que &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt; oculta a &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;.&lt;/p&gt;

&lt;h3 id=&quot;imposibilidad-de-descencriptacin&quot;&gt;3. Imposibilidad de descencriptación&lt;/h3&gt;

&lt;p&gt;Para cada posible valor de salida &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt;, si &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; se escoge de una distribución con alta entropía de Renyi, entonces es inviable encontrar &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; tal que 
&lt;script type=&quot;math/tex&quot;&gt;H(k|x)=y&lt;/script&gt;. Lo que esto quiere decir es que la única forma de encontrar &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; es recorrer un espacio muy grande de valores que sólo pueden aparecer de forma aleatoria.&lt;/p&gt;

&lt;h2 id=&quot;punteros-hash&quot;&gt;Punteros hash&lt;/h2&gt;

&lt;p class=&quot;marco-de-foto&quot;&gt;&lt;img src=&quot;/images/puntero-hash.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Un puntero hash es una estructura donde se almacena cierta información y el hash de esa información. Si tenemos un puntero hash, podemos
indagar por la información y verificar que no se ha alterado.
La idea es crear estructuras de datos con estos punteros, como listas enlazadasy y árboles binarios.&lt;/p&gt;

&lt;h2 id=&quot;lista-enlazada-blockchain&quot;&gt;Lista enlazada (blockchain)&lt;/h2&gt;

&lt;p&gt;Una representación es una lista enlazada:&lt;/p&gt;

&lt;p class=&quot;marco-de-foto&quot;&gt;&lt;img src=&quot;/images/linked-hash.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Si un atacante cambia los datos de un bloque, el hash de ese bloque cambia. Esta inconsistencia es fácilmente detectable con el hash principal. Un atacante incuso puede alterar todos los bloques pero no el hash raíz que tenemos almacenado.&lt;/p&gt;

&lt;p class=&quot;marco-de-foto&quot;&gt;&lt;img src=&quot;/images/tamper-proof.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;rbol-de-merkle&quot;&gt;Árbol de Merkle&lt;/h2&gt;

&lt;p&gt;Otra estructura de datos que se puede crear con punteros es un árbol binario también llamado árbol de Merkle.
Tomamos pares consecutivos de bloques de datos y creamos una estructura que contiene dos punteros hash (uno para cada bloque). En un nivel superior se otra estructura similar que apunta a dos bloques inferiores
y así hasta llegar a la raíz del árbol.&lt;/p&gt;

&lt;p class=&quot;marco-de-foto&quot;&gt;&lt;img src=&quot;/images/merkle-tree.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Una característica importante del árbol de Merkle es que es muy fácil verificar un bloque de datos. Lo que se hace es verificar los hash de la rama a la que pertenece.
Si se verifican los hash hasta la raíz se puede comprobar la pertenencia al árbol incluso si el árbol es extenso y contiene muchos niveles. Se puede hacer en esto en un tiempo razonable &lt;script type=&quot;math/tex&quot;&gt;O(log n)&lt;/script&gt;.&lt;/p&gt;

&lt;p class=&quot;marco-de-foto&quot;&gt;&lt;img src=&quot;/images/merkle2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 02 Jan 2019 00:00:00 -0500</pubDate>
        <link>https://leonardo384.github.io/bitcoin/2019/01/02/la-funcion-hash-criptografica/</link>
        <guid isPermaLink="true">https://leonardo384.github.io/bitcoin/2019/01/02/la-funcion-hash-criptografica/</guid>
        
        
        <category>bitcoin</category>
        
      </item>
    
      <item>
        <title>Documentación Técnica de Bitcoin</title>
        <description>&lt;div style=&quot;text-align:center; line-height: 0.5&quot;&gt;
  &lt;h3&gt;Bitcoin: Un Sistema Distribuido de Dinero Electrónico&lt;/h3&gt;
  &lt;div style=&quot;margin: 32px 0 32px 0;&quot;&gt;
  &lt;p&gt;Satoshi Nakamoto&lt;/p&gt;
  &lt;p&gt;satoshin@gmx.com&lt;/p&gt;
  &lt;p&gt;www.bitcoin.org&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;div style=&quot;font-size: 90%; text-align: justify; width: 80%; margin: auto;&quot;&gt;
&lt;b&gt;Resumen&lt;/b&gt;. Una versión de dinero electrónico basada totalmente en la cooperación entre participantes permitiría que los pagos en linea se
envíen directamente de un participante a otro sin pasar por una institución financiera.
Las firmas digitales representan parte de la solución, pero los beneficios principales
se pierden si se require una tercera persona para evitar el doble gasto. Proponemos una solución
al problema del doble gasto usando una red entre pares. La red marca cronológicamente las transacciones por medio de un hash que se incluye en una cadena
sucesiva de prueba de trabajo basado en hashes, creando un registro que no se puede modificar
sin rehacer la prueba de trabajo. La cadena más larga no solo sirve como prueba de la secuencia de los eventos ocurridos, sino también como prueba de su proveniencia del grupo con mayor poder de CPU.
Siempre que la mayoría del poder de CPU sea controlada por nodos que no estén cooperando para atacar la red, éstos generarán la cadena más larga y sobrepasarán a los atacantes.
La red misma requiere una estructuración mínima. Los mensajes se transmiten con base en el mejor esfuerzo y los nodos pueden abandonar y luego regresar a la red
a voluntad aceptando la cadena de prueba de trabajo más larga como prueba de lo sucedido
mientras estaban ausentes.
&lt;/div&gt;

&lt;h2 id=&quot;introduccin&quot;&gt;1. Introducción&lt;/h2&gt;

&lt;p&gt;El comercio en linea ha llegado a depender casi exclusivamente de las instituciones financieras que funcionan como intermediarios de confianza para
procesar pagos electrónicos. Si bien el sistema funciona lo suficientemente bien para la mayoría de las transacciones, todavía sufre de las debilidades
inherentes del modelo basado en la confianza. Las transacciones completamente irreversibles no son realmente posibles ya que las instituciones financieras no pueden
evitar inmiscuirse en la resolución de las disputas. El costo de la concialiación aumenta los costos de la transacción, lo que limita el tamaño práctico mínimo de la transacción, eliminando la posibilidad de transacciones pequeñas ocasionales y pagos irreversibles para servicios irreversibles.
Al ser posible revertir una transacción, se aumenta la necesidad de mutua confianza. Los comerciantes deben desconfiar de sus clientes exigiéndoles más información de lo que realmente se necesita. Cierto porcentaje de fraude es aceptado como algo inevitable. Estas incertidumbres de costos y pagos
se pueden evitar personalmente usando dinero en efectivo; sin embargo no hay un mecanismo para hacer pagos a través de un canal de comunicación sin un tercero de confianza.
Lo que se necesita es un sistema de pago electrónico basado en una prueba criptográfica en vez de una fiducia, lo que permitiría a dos partes cualesquieras hacer una transacción directamente entre sí sin la necesidad de una fiducia.
Las transacciones que son computacionalmente imprácticas de revertir protegerían a los vendedores del fraude y se podrían implementar mecanismos rutinarios de garantía para proteger a los compradores.
En este documento se propone una solución al problema del gasto doble usando un servidor distribuido que registra el tiempo preciso para generar una prueba computacional del orden cronológico de las transacciones. El sistema es seguro siempre y cuando
los nodos controlen colectivamente más poder de CPU que cualquier grupo de atacantes que cooperen juntos.&lt;/p&gt;

&lt;h2 id=&quot;las-transacciones&quot;&gt;2. Las Transacciones&lt;/h2&gt;

&lt;p&gt;Definimos una moneda electrónica como una cadena de firmas electrónicas.
Cada poseedor transfiere la moneda a la siguiente persona firmando digitalmente un hash de la transacción previa y la clave pública del siguiente dueño y agregando éstos al final de la moneda.
El destinatario puede verificar las firmas para comprobar la cadena de propiedad.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/transactions.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;El problema por supuesto es que el destinatario no puede verificar si uno de los dueños usó la moneda dos veces.
Una solución común es incluir una autoridad central confiable, o emisor de monedas, que revisa si hubo doble gasto en cada transacción.
Luego de cada transacción, la moneda debe ser regresada al emisor de monedas para emitir una nueva moneda y solo las monedas creadas directamente por el emisor se consideran que no fueron gastadas doblemente.
El problema con esta solución es que el destino de todo el sistema monetario depende de la compañía emisora y cada transacción debe pasar por allí tal como un banco.&lt;/p&gt;

&lt;p&gt;Necesitamos una manera que el destinatario sepa que los dueños anteriores no firmaron transacciones previas. Para nuestros propósitos,
la transacción previa es la que cuenta, de modo que no nos preocupamos por intentos posteriores de gasto doble.
La única forma de confirmar la ausencia de una transacción es estar al tanto de todas las transacciones. En el modelo del emisor de moneda, el emisor estaba al tanto de todas las transacciones y decidía cual llegaba primero.
Para lograr esto sin un intermediario fiable, las transacciones deben ser anunciadas públicamente [1], y necesitamos un sistema de participantes para que esten de acuerdo en un solo historial
del orden en las que fueron recibidas. El beneficiario necesita la prueba de que en el momento de cada transacción, la mayoría de los nodos acordaron que esa fue la primera recibida.&lt;/p&gt;

&lt;h2 id=&quot;el-servidor-de-registro-cronolgico&quot;&gt;3. El Servidor de Registro Cronológico&lt;/h2&gt;

&lt;p&gt;La solución que proponemos inicia con un servidor de registro cronológico. Un servidor de este tipo toma un hash de un bloque de
objetos para ser registrados cronológicamente y divulga el hash en medios como un periódico o una publicación de Usenet [2-5].
El registro cronológico prueba que los datos debieron existir en el momento, obviamente, para poder ser incluidos en el hash. Cada registro cronológico incluye el registro anterior en su propio hash formando así una cadena. Esto permite a cada registro adicional reforzar los anteriores.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/timestamp-server.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;la-prueba-de-trabajo&quot;&gt;4. La Prueba de Trabajo&lt;/h2&gt;

&lt;p&gt;Para implementar un servidor distribuido de registro cronológico  entre pares, necesitaremos usar un sistema de prueba de trabajo similar al HashCash de Adam Back [6] en vez de publicaciones en un periódico o Usenet.
La prueba de trabajo involucra la lectura de un valor que cuando se le aplica hash, por ejemplo, por medio de SHA-256, éste comienza con una serie de bits cero.
El promedio de trabajo necesario es exponencial a la cantidad de bits cero necesarias y se puede verificar ejecutando un hash simple.&lt;/p&gt;

&lt;p&gt;Para nuestro servidor de registro cronológico, implementamos la prueba de trabajo aumentando el valor único (nonce) en el bloque hasta que se encuentra un valor que le da al hash del bloque los bits cero requeridos.
Una vez el esfuerzo CPU se ha utilizado por completo para satisfacer la prueba de trabajo, el bloque no se puede modificar sin rehacer el trabajo. A medida que bloques posteriores se encadenan, el trabajo para modificar el bloque incluiría rehacer todos los bloques siguientes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/proof-of-work.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;La prueba de trabajo también soluciona el problema de determinar la representación en la toma de decisiones por la mayoría. Si la mayoría se basara en una dirección IP - un voto, podría corromperse por cualquiera capaz de asignarse muchas direcciones IPs.
La prueba de trabajo es básicamente un CPU - un voto. La decisión mayoritaria se representa con la cadena más larga que a su vez tiene la mayor prueba de trabajo aplicada. Si una mayoría de poder CPU es controlada por nodos honestos, la cadena honesta va a crecer más rápidamente y va a sobrepasar cualquier cadena rival.
Para modificar un bloque previo, un atacante tendría que rehacer la prueba de trabajo del bloque y de los bloques posteriores y luego alcanzar y superar el trabajo de los nodos honestos.
Mostraremos más adelante que la probabilidad de que un atacante más lento  se ponga a la par disminuye exponencialmente a medida que se agregan bloques adicionales.&lt;/p&gt;

&lt;p&gt;Para compensar el incremento de la velocidad del hardware y el interés variable de ejecutar nodos a lo largo del tiempo, la dificultad de la prueba de trabajo se determina por un promedio variable
que apunta a un número promedio de bloques por hora. Si se generan muy rápido, la dificultad se incrementa.&lt;/p&gt;

&lt;h2 id=&quot;la-red&quot;&gt;5. La Red&lt;/h2&gt;

&lt;p&gt;Los pasos para iniciar la red son los siguientes:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Se transmiten las nuevas transacciones a todos los nodos&lt;/li&gt;
  &lt;li&gt;Cada nodo alamacena las nuevas transacciones en un bloque.&lt;/li&gt;
  &lt;li&gt;Cada nodo trabaja en hallar una prueba de trabajo difícil para su bloque.&lt;/li&gt;
  &lt;li&gt;Cuando un nodo halla una prueba de trabajo, transmite el bloque a todos los nodos.&lt;/li&gt;
  &lt;li&gt;Los nodos aceptan el bloque sólo si todas las transacciones en él son válidas o no han sido gastadas.&lt;/li&gt;
  &lt;li&gt;Los nodos expresan su asentimiento del bloque comenzando a trabajar en la creación del siguiente bloque en la cadena, usando el hash del bloque aceptado como el hash previo.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Los nodos siempren asumen que la cadena más larga es la correcta y se van a segurir trabajando para extenderlo.
Si dos nodos transmiten diferentes versiones de bloque siguiente simultáneamente, algunos nodos pueden recibir una u otra primero. En ese caso, ellos trabajan en la primera versión que recibieron, pero guardan la otra ramificación
en el caso de que ésta se convierta en la más larga. El empate se resuelve cuando se encuentre la siguiente prueba de trabajo y una de las ramificaciones sea más larga; los nodos que estaban trabajando en la otra ramificación ahora se pasan a la más larga.&lt;/p&gt;

&lt;p&gt;Las nuevas transmisiones de transacciones no tienen que llegar necesariamente a todos los nodos. Siempre que alcancen muchos nodos ellos van a ser incluidos en un bloque tarde o temprano. Las transmisiones de los bloques también son tolerantes a los mensajes no recibidos. Si un nodo no recibe un bloque, lo va a solicitar cuando reciba el siguiente bloque y se de cuenta que le faltaba uno.&lt;/p&gt;

&lt;h2 id=&quot;los-incentivos&quot;&gt;6. Los Incentivos&lt;/h2&gt;

&lt;p&gt;Por convención, la primera transacción es una transacción especial que genera una moneda que le pertenece al creador del bloque. Esto crea un incentivo para que los nodos respalden la red y establece una manera de poner monedas inicialmente en circulación ya que no hay una autoridad central que las emita.
La adición continua de una cantidad constante de monedas es análogo a la minería de oro en la que gastan recursos para poner el oro en circulación. En nuestro caso es el tiempo de CPU y la electricidad lo que se gasta.&lt;/p&gt;

&lt;p&gt;El incentivo también pude ser financiado a través de comisiones de transacción. Si el valor de salida de una transacción es menor que su valor de entrada, la diferencia es una comisión de transacción que se agrega al valor de incentivo del bloque que contiene la transacción.
Una vez que un número predeterminado de monedas han entrado en circulación, el sistema de incentivos puede entrar en una etapa de transición basado en comisiones de transacción siendo completamente libre de inflación.&lt;/p&gt;

&lt;p&gt;El incentivo puede ayudar a estimular a los nodos para que permanezcan honestos. Si un atacante codicioso es capaz de juntar más poder de CPU que todo el resto
de los nodos, le tocará escoger entre usar este poder para defraudar a la gente robándole sus pagos o usar este poder para generar nuevas monedas. Él debería encontrar
más provechoso seguir las reglas que lo favorecen con más nuevas monedas que todos los demás en la red, que subvertir el sistema y la validez de su propia fortuna.&lt;/p&gt;

&lt;h2 id=&quot;reduccin-de-espacio-de-memoria&quot;&gt;7. Reducción de Espacio de Memoria&lt;/h2&gt;

&lt;p&gt;Una vez la más reciente transacción de una moneda se engrana bajo suficientes bloques, las transacciones completadas anteriormente se pueden descartar para ahorrar espacio de disco.
Para facilitar esto sin romper el hash del bloque, se aplica un hash a las transacciones en un Árbol de Merkle [7][2][5], incluyendo sólo la raíz en el hash del bloque.
Los bloques anteriores pueden luego ser compactados podando las ramificacións del árbol. Los hash interiores no tienen que ser almacenados.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/reclaiming-disk-space.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Una cabecera de bloque sin transacciones tendría alrededor de 80 bytes. Si suponemos que los bloques se generan cada 10 minutos, 80 bytes * 6 * 24 * 365 = 4.2MB por año.
Con sistemas de computación que se venden con 2GB de RAM en 2008 y la ley de Moore que predice un crecimiento actual de 1.2GB por año, el almacenamiento no debería ser un problema incluso si las cabeceras de los bloques deben permanecer en la memoria.&lt;/p&gt;

&lt;h2 id=&quot;verificacin-simplificada-de-pago&quot;&gt;8. Verificación Simplificada de Pago&lt;/h2&gt;

&lt;p&gt;Es posible verificar los pagos sin tener que correr un nodo de red completo. Un usuario solo necesita mantener una copia de las cabeceras del bloque de la cadena de prueba de trabajo más larga, que puede obtener
consultando los nodos de la red hasta convencerse de tener la cadena más extensa y obtener la ramificación de Merkle que relaciona la transacción con el bloque donde está registrada cronológicamente. No puede revisar la transacción él mismo sino que al relacionarla con un lugar en la cadena pude ver que un nodo de la red la ha aceptado y los bloques agregadoe posteriormente sólo confirman esta aceptación por parte de la red.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/simplified-payment-verification.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;La verificación como tal es confiable siempre y cuando los nodos honestos controlen la red pero es más vulnerable si la red es sobrepasada por un atacante.
Si bien los nodos de red pueden verificar las transacciones por si solos, el método simplificado puede ser burlado por transacciones falsas de un atacante mientras éste continue dominando la red. Una estrategia para protegerse de este caso sería aceptar alertas de los nodos cuando detecten un bloque inválido anunciando al software del usuario para que descargue el bloque completo con las transacciones sospechosas para confirmar la inconsistencia.
Los negocios que reciben pagos frecuentes probablemente querrán correr sus propios nodos para una mayor seguridad y una rápida verificación.&lt;/p&gt;

&lt;h2 id=&quot;combinando-y-dividiendo-el-valor&quot;&gt;9. Combinando y Dividiendo el Valor&lt;/h2&gt;

&lt;p&gt;Aunque sería posible manejar monedas en forma individual, sería insostenible hacer una transacción separada por cada centavo en una transferencia. Para permitir la división y combinación del valor, las transacciones contienen múltiples entradas y salidas.
Normalmente habrá o bien una sola entrada de una transacción previa grande o múltiples entradas que combinan montos más pequeños y además como mucho dos salidas: una para el pago y una devolviendo el cambio, si lo hay, de nuevo al remitente.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/combining-splitting-value.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Debe tenerse en cuenta que la expansión, es decir, donde una transacción depende de varias transacciones y éstas dependen de muchas más, no es un problema aquí.
No existe nunca la necesidad de extraer la copia completa del historial de una transacción individual.&lt;/p&gt;

&lt;h2 id=&quot;privacidad&quot;&gt;10. Privacidad&lt;/h2&gt;

&lt;p&gt;El modelo tradicional de banca alcanza un nivel de privacidad al limitar el acceso a la información a las partes involucradas y al intermediario de confianza.
La necesidad de anunciar todas las tranzacciones al público imposibilita este método, pero la privacidad aún se puede mantener bloquenado el flujo de información en otro lugar: manteniendo las claves privadas anónimas.
El público puede ver que alguien envia una cantidad a alguien más pero sin relacionar la transacción con nadie.
Esto es similar al nivel de información divulgado por las bolsas de valores donde se anuncia la hora y el tamaño de los movimientos individuales, el “registro”,  pero sin decir quienes fueron las partes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/privacy.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Como cortafuegos adicional, debe usarse un nuevo par de claves para cada transacción para evitar que sean relacionadas con un dueño común. Alguna forma de vinculación es todavía inevitable con las transacciones de entradas múltiples que necesariamente revelan que las entradas eran poseidas por el mismo dueño. El riesgo es que si el dueño de una clave es revelado, el vínculo puede revelar otras transacciones que pertenecieron al mismo dueño.&lt;/p&gt;

&lt;h2 id=&quot;clculos&quot;&gt;11. Cálculos&lt;/h2&gt;

&lt;p&gt;Consideramos el escenario de un atacante tratando de generar una cadena alterna más rápido que la cadena honesta. Incluso si esto se logra alcanzar, no implica que el sistema sea propenso a cambios arbitrarios tales como la creación de valor a partir de nada o la posesión de dinero que nunca perteneció al atacante. Los nodos no van a aceptar una transacción inválida como pago y los nodos honestos nunca aceptarán un bloque que los contiene.
Un atacante solo puede tratar de cambiar una de sus propias transacciones para recuperar dinero que gastó antes.&lt;/p&gt;

&lt;p&gt;La competencia entre la cadena honesta y la cadena del atacante se puede caracterizar como un Camino Aleatorio Binomial. El evento éxito es que la cadena honesta se extienda un bloque aumentando su ventaja +1, y el evento fracaso es la cadena del atacante extendiéndose un bloque reduciendo la brecha por -1.&lt;/p&gt;

&lt;p&gt;La probabilidad de que un atacante se ponga al día a partir de un deficit dado es análogo al problema de la Ruina del Apostador.
Suponga que un apostador con crédito ilimitado comienza con un deficit y juega potencialmente un número infinito de intentos para tratar de alcanzar una paridad. podemos calcular la probabilidad de que alguna vez alcance la paridad
o que en nuestro caso el atacante alcance la cadena honesta de la siguiente forma:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{eqnarray*}
                \large p &amp;=&amp; \text{ probabilidad de que un nodo honesto encuentre el próximo bloque}\\
                \large q &amp;=&amp; \text{ probabilidad de que el atacante encuentre el próximo bloque}\\
                \large q_z &amp;=&amp; \text{ probabilidad de que el atacante alguna vez alcance a los demás a partir de $z$ bloques atrás}
                \end{eqnarray*} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\large q_z = \begin{Bmatrix}
				1 &amp; \textit{si}\; p \leq q\\
				(q/p)^z &amp; \textit{si}\; p &gt; q
				\end{Bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;Dada la suposición de que  &lt;script type=&quot;math/tex&quot;&gt;p \gt q&lt;/script&gt;, la probabilidad disminuye exponencialmente a medida que el número de bloques que el atacante debe alcanzar aumenta.&lt;/p&gt;

&lt;p&gt;Ahora consideramos cuanto tiempo el destinatario de una nueva transacción debe esperar antes de estar lo suficientemente seguro que el remitente no pueda cambiar la transacción. Asumimos que el remitente es un atacante
que quiere hacer que el destinatario esté convencido por un tiempo de que se le hizo el pago, luego hacer el cambio para pagarse a sí mismo más tarde. El destinatario será alertado cuando eso pase, pero el remitente va a tener la esperanza de que sea demasiado tarde.&lt;/p&gt;

&lt;p&gt;El destinatario genera un nuevo par de claves y da la clave pública al remitente justo antes de firmar. Esto evita que el remitente prepare una cadena de bloques con anticipación y procesándolo continuamente hasta que es lo bastante afortunado para avanzar lo suficiente y realizar la transacción en ese momento.
Una vez la transacción es enviada, el remitente deshonesto comienza a trabajar en secreto en una cadena paralela que contiene una versión alterna de la transacción.&lt;/p&gt;

&lt;p&gt;El destinatario espera hasta que la transacción ha sido añadida a un bloque y &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; bloques han sido enlazados luego de ese. Él no sabe la cantidad exacta de progreso que el atacante ha logrado, pero asumiendo que los nodos honestos invirtieron el promedio esperado de tiempo
por bloque, el progreso potencial del atacante será una distribución de Poisson con el valor esperado:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\large \lambda = z \frac qp&lt;/script&gt;

&lt;p&gt;Para obtener la probabilidad de un que un atacante pueda ponerse a la par de los demás, multiplicamos la densidad de Poisson para cada nivel de progreso que haya podido alcanzar por la probabilidad de que pueda ponerse al día a partir de ese punto:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\large \sum_{k=0}^{\infty} \frac{\lambda^k e^{-\lambda}}{k!} \cdot
				\begin{Bmatrix}
				(q/p)^{(z-k)} &amp; \textit{if}\;k\leq z\\
				1 &amp; \textit{if} \; k &gt; z
				\end{Bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;Reacomodando para evitar sumar la cola infinita de la distribución…&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\large 1 - \sum_{k=0}^{z} \frac{\lambda^k e^{-\lambda}}{k!}
				\left ( 1-(q/p)^{(z-k)} \right )&lt;/script&gt;

&lt;p&gt;Convirtiendo a código C…&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ProbabilidadDeExitoDeUnAtacante&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;poisson&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;poisson&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;poisson&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Al ejecutar algunos resultados podemos ver como la probabilidad disminuye exponencialmente con &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0000000&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2045873&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;050&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9779&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0131722&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0034552&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;000&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9137&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;000242&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0000647&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0000173&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0000046&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0000012&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0000000&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1773523&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0416605&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;010100&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0024&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;804&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0006132&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0001522&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;35&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;000037&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;00000&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;95&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0000024&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0000006&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Resolviendo para P menor que 0.1%…&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;001&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;35&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;41&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;89&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;340&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;conclusin&quot;&gt;12. Conclusión&lt;/h2&gt;

&lt;p&gt;Hemos propuesto un sistema de transacciones electrónicas que no dependen de la buena fe. Comenzamos con el marco usual de monedas hechas a partir de firmas digitales que brindan un fuerte control de propiedad pero es incompleto sin una forma de prevenir el doble gasto.
Para resolver esto, propusimos una red entre pares que usa la prueba de trabajo para guardar un historial público de transacciones que rápidamente terminan siendo computacionalmente imprácticas de cambiar por parte de un atacante si los nodos honestos controlan la mayoría de poder de CPU. La red es robusta en su simplicidad no estructurada.
Los nodos trabajan todos a la vez con poca coordinación. No necesitan ser identificados ya que los mensajes no son enrutados a un lugar particular y solo deben ser transmitidos con base en el mejor esfuerzo. Los nodos pueden abandonar y retomar la red a voluntad aceptando la cadena de prueba de trabajo como prueba de lo que pasó cuando estaban ausentes. Ellos votan con su poder de CPU
expresando su aprobación de los bloques válidos al ponerse a trabajar en extenderlos y rechazando a su vez los bloques inválidos al negarse a procesarlos. Cualquier regla o incentivo puede se puede hacer cumplir con este mecanismo de consenso.&lt;/p&gt;

&lt;h2 id=&quot;referencias&quot;&gt;Referencias&lt;/h2&gt;

&lt;p&gt;[1] W. Dai, “b-money,” http://www.weidai.com/bmoney.txt, 1998.&lt;br /&gt;
[2] H. Massias, X.S. Avila, and J.-J. Quisquater, “Design of a secure timestamping service with minimal trust requirements,” In &lt;em&gt;20th Symposium on Information Theory in the Benelux&lt;/em&gt;, May 1999.&lt;br /&gt;
[3] S. Haber, W.S. Stornetta, “How to time-stamp a digital document,” In &lt;em&gt;Journal of Cryptology&lt;/em&gt;, vol 3, no 2, pages 99-111, 1991.&lt;br /&gt;
[4] D. Bayer, S. Haber, W.S. Stornetta, “Improving the efficiency and reliability of digital time-stamping,” In &lt;em&gt;Sequences II: Methods in Communication, Security and Computer Science&lt;/em&gt;, pages 329-334, 1993.&lt;br /&gt;
[5] S. Haber, W.S. Stornetta, “Secure names for bit-strings,” In &lt;em&gt;Proceedings of the 4th ACM Conference on Computer and Communications Security&lt;/em&gt;, pages 28-35, April 1997.&lt;br /&gt;
[6] A. Back, “Hashcash - a denial of service counter-measure,”&lt;br /&gt;
http://www.hashcash.org/papers/hashcash.pdf, 2002.&lt;br /&gt;
[7] R.C. Merkle, “Protocols for public key cryptosystems,” In &lt;em&gt;Proc. 1980 Symposium on Security and Privacy&lt;/em&gt;, IEEE Computer Society, pages 122-133, April 1980.&lt;br /&gt;
[8] W. Feller, “An introduction to probability theory and its applications,” 1957.&lt;/p&gt;
</description>
        <pubDate>Thu, 27 Dec 2018 11:56:53 -0500</pubDate>
        <link>https://leonardo384.github.io/bitcoin/2018/12/27/documentacion-tecnica-de-bitcoin/</link>
        <guid isPermaLink="true">https://leonardo384.github.io/bitcoin/2018/12/27/documentacion-tecnica-de-bitcoin/</guid>
        
        
        <category>bitcoin</category>
        
      </item>
    
  </channel>
</rss>
