<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Documentación Técnica de Ethereum</title>
  <meta name="description" content="La intención de Ethereum es crear un protocolo alternativo para desarrollar aplicaciones descentralizadasal introducir un conjunto nuevo de aspectos que cree...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://leonardo384.github.io/criptomonedas/2019/01/05/documentacion-tecnica-de-ethereum/">
  
  <link rel="alternate" type="application/rss+xml" title="Bitcoin y Criptomonedas" href="https://leonardo384.github.io/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Bitcoin y Criptomonedas</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/acerca/">Acerca</a>
          
        
          
          <a class="page-link" href="/bitcoin/">Bitcoin</a>
          
        
          
          <a class="page-link" href="/criptomonedas/">Criptomonedas</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Documentación Técnica de Ethereum</h1>
    <p class="post-meta"><time datetime="2019-01-05T00:00:00-05:00" itemprop="datePublished">Jan 5, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>La intención de Ethereum es crear un protocolo alternativo para desarrollar aplicaciones descentralizadas
al introducir un conjunto nuevo de aspectos que creemos serán de gran uso en una clase extensa de aplicaciones descentralizadas, sobretodo en situaciones
donde importan el tiempo de desarrollo, la seguridad para aplicaciones pequeñas y poco usadas,
y la capacidad de interacción eficiente de diferentes aplicaciones. Ethereum logra esto construyendo lo que esencialmente es la mayor capa fundamental abstracta: un blockchain con un lenguaje Turing completo incorporado que le permite a cualquiera escribir contratos inteligentes y aplicaciones
descentralizadas donde se pueden crear reglas propias y arbitrarias de propiedad, formatos de transacción y funciones de transición de estado.
Se puede escribir una versión esencial de Namecoin en solo dos líneas de código y otros protocolos tales como divisas y sistemas de reputación en menos de veinte líneas.
También se pueden crear sobre la plataforma contratos inteligentes que son especies de  “cajas” criptográficas que contienen un valor y lo revelan solo si se cumplen ciertas condiciones.
Éstas tienen mucho más poder que las que ofrece el código de Bitcoin debido a las capacidades agregadas de la completitud de Turing, el reconocimiento del valor, del blockchain y del estado.</p>

<h3 id="filosofa">Filosofía</h3>

<p>El diseño detrás de Ethereum debe seguir los siguientes principios:</p>

<ol>
  <li>
    <p><strong>Simplicidad</strong>: el protocolo Ethereum debe ser tan simple como sea posible, incluso sacrificando el amacenamiento de datos y la eficiencia de tiempo. Un programador promedio
debería ser capaz de seguir e implementar una especificación completa, dándose cuenta del potencial sin precedentes de democratización que las criptomonedas traen y extendiendo la visión
de Ethereum como un protocolo abierto a todos. Ninguna optimización que agregue complejidad se debería incluir a menos que esa optimización brinde beneficios considerables.</p>
  </li>
  <li>
    <p><strong>Universalidad</strong>: una parte fundamental de la filosofía de diseño es que Ethereum no tiene “características”.
En vez de eso, Ethereum trae un lenguaje interno de codificación Turing completo que un programador puede usar
para crear cualquier contrato inteligente o tipo de transacción que puede ser definido matemáticamente.
¿Quiere crear su propio producto financiero? Con Ethereum se puede. ¿Quiere crear su propia moneda? Desarróllelo como un contrato en Ethereum. ¿Quiere montar un script de ejecución constante o Skynet completo?
Podría necesitar tener varios miles de contratos interconectados y asegurarse de llenarlos de información, pero también se puede en Ethereum.</p>
  </li>
  <li>
    <p><strong>Modularidad</strong>: las partes del protocolo Ethereum deben ser diseñados para ser tan modulares y separables como sea posible.
Durante la fase de desarrollo, nuestro objetivo es crear un programa en donde si se necesita hacer una pequeña modificación del protocolo en un lugar, el stack de la aplicación
seguirá funcionando sin más cambios. Las innovaciones como Ethash, los árboles modificados de Patricia y RLP (Recursive Length Prefix)
deberían y son implementados como bibliotecas separadas y completas. Este es el procedimiento para que ciertas características disponibles en Ethereum se puedan transferir a otros protocolos, incluso si Ethereum no las aplica. El desarrollo en Ethereum debería ser para beneficiar lo más posible al ecosistema de criptomonedas en general y no solo a Ethereum.</p>
  </li>
  <li>
    <p><strong>Agilidad</strong>: los detalles del protocolo Ethereum no son inflexibles. Aunque seremos extremadamente cuidadosos al modificar estructuras de alto nivel.
Un ejemplo es la hoja de ruta de partición (sharding roadmap) donde se abstrae la ejecución dependiendo de la disponibilidad de datos que cumplan con el consenso.
Los tests computacionales posteriores en el proceso de desarrollo nos pueden llevar a descubrir que ciertas modificaciones, por ejemplo, al protocolo de arquitectura de la Máquina Virtual de Ethereum (EVM), van a mejorar la escalabilidad o la seguridad. Si esas ocasiones se presentan, las vamos a aprovechar.</p>
  </li>
  <li>
    <p><strong>No discriminación</strong> y <strong>no censura</strong>: el protocolo no debería tratar de restringir o prevenir categorías específicas de uso. Todos los mecanismos regulatorios en el protocolo deberían ser diseñados para regular directamente el daño y no tratar de oponerse a aplicaciones específicas no deseadas. Un programador puede incluso ejecutar un bucle infinito encima de Ethereum mientras esté dispuesto a seguir pagando el costo de la transacción de cada instrucción de cómputo.</p>
  </li>
</ol>

<h3 id="las-cuentas-de-ethereum">Las cuentas de Ethereum</h3>

<p>En Ethereum el estado se compone de objetos llamados “cuentas” cada una con una dirección de 20 bytes y con estados de transición que representan transferencias directas de valor e información entre cuentas. Una cuenta de Ethereum contiene cuatro campos:</p>

<ul>
  <li>El número único (nonce) que se usa para asegurarse de que cada transacción se pueda procesar solo una vez.</li>
  <li>El balance actual de ether de la cuenta</li>
  <li>El código de contrato de la cuenta si existe</li>
  <li>El almacenamiento de la cuenta (vacío por defecto)</li>
</ul>

<p>“Ether” es el principal criptocombustible de Ethereum y se usa para pagar costos de transacción. En general, hay dos tipos de cuentas: <strong>cuentas de propiedad externa</strong>, controladas por claves privadas y <strong>cuentas de contrato</strong> controladas por código de contrato. Una cuenta de propiedad externa no tiene código y se pueden enviar mensajes desde una de estas cuentas creando y firmando una transacción; en una cuenta de contrato, cada vez que se recibe un mensaje, el código se activa, lo que permite leer y escribir al almacenamiento interno y enviar otros mensajes o crear contratos a su vez.</p>

<p>Nótese que los “contratos” en Ethereum no deben verse como algo que debe ser “ejecutado” o “cumplido”; son más bien como “agentes autónomos” que viven dentro del ambiente de ejecución de Ethereum y siempre están ejecutando un segmento específico de código cuando son “despertados” por un mensaje o una transacción y además tienen control directo sobre su propio balance de ether y tienen su propio almacenamiento tipo clave/valor para registrar variables persistentes.</p>

<h3 id="mensajes-y-transacciones">Mensajes y Transacciones</h3>

<p>El término “transacción” se usa en Ethereum para referirse a un paquede de datos firmado que guarda un mensaje que se va a enviar a una cuenta de propiedad externa. Las transacciones contienen:</p>

<ul>
  <li>El destinatario del mensaje</li>
  <li>Una firma que identifica al remitente</li>
  <li>La cantidad de ether que se transfiere de remitente a destinatario</li>
  <li>Un campo de datos opcional</li>
  <li>un valor STARTGAS que representa el número máximo de instrucciones computacionales que la ejecución de la transacción tiene permitido hacer</li>
  <li>Un valor GASPRICE que representa pago que el remitente hace por cada instrucción computacional</li>
</ul>

<p>Los primeros tres son campos estándar que se esperan en cualquier criptomoneda. El campo de datos no tiene una función por defecto, pero la máquina virtual tiene un código de operación que un contrato puede usar para acceder a los datos. Como un ejemplo de caso de uso, si un contrato está funcionando como servicio de registro de dominios basado en blockchain, entonces podría interpretar los datos que está recibiendo como compuestos de dos campos: el primer campo es el dominio que hay que registrar y el segundo campo es la dirección IP a la que hay que asociar. El contrato leería estos valores desde los datos del mensaje y los guardaría apropiadamente en el almacenamiento.</p>

<p>Los campos STARTGAS y GASPRICE son cruciales para el modelo antinegación de servicio (DDoS). de Ethereum. Para evitar bucles infinitos accidentales u hostiles o cualquier otro  desperdicio computacional en código, cada transacción necesita establecer un límite acerca de cuantas instrucciones computacionales de ejecución de código puede utilizar. La unidad fundamental de computación es el “gas”; generalmente una instrucción computacional cuasta 1 gas aunque ciertas operaciones tiene un mayor costo por ser más intensas computacionalmente o porque aumentan la cantidad de datos que debe ser almacenado como parte del estado. También hay un pago de 5 gas para cada byte en los datos de transacción. La intención del sistema de pagos es para exigir a un atacante que pague proporcionalmente a cada recurso que consume incuido computacón, ancho de banda y almacenamiento. De esta forma, cualquier transacción que lleve al consumo de una mayor cantidad de cualquiera de estos recursos debe pagar una comisión en gas justamente proporcional al ese incremento</p>

<h3 id="mensajes">Mensajes</h3>

<p>Los contratos tienen la capacidad de enviar “mensajes” a otros contratos. Los mensajes son objetos virtuales que nunca se serializan y solo existen en el ambiente de ejecución de Ethereum. Un mensaje contiene:</p>

<ul>
  <li>El remitente del mensaje (implícito)</li>
  <li>El destinatario del mensaje</li>
  <li>La cantidad de ether para transferir junto con el mensaje</li>
  <li>Un campo de datos opcional</li>
  <li>Un valor de STARTGAS</li>
</ul>

<p>Básicamente un mensaje es como una transición, excepto que es producido por un contrato y no un actor central. Un mensaje se produce cuando el código actual en ejecución del contrato llama al código operacional <code class="highlighter-rouge">CALL</code> el cual crea y ejecuta un mensaje. Al igual que en una transacción, un mensaje causa que la cuenta del remitente ejecute su código. Así, los contratos pueden relacionarse con otros contratos de la misma forma que los actores externos lo hacen.</p>

<h3 id="la-funcin-de-transicin-de-estado-de-ethereum">La Función de Transición de Estado de Ethereum</h3>

<p><img src="https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/ethertransition.png" alt="funcion de transicion estado de etehereum" /></p>

<p>La función de transición de estado de Ethereum, <code class="highlighter-rouge">APPLY(S, TX) -&gt; S'</code> se puede definir así:</p>

<ol>
  <li>Revisa si la transacción está bien formada (es decir, tiene el número correcto de valores), si la firma es válida y el nonce corresponde al nonce en la cuenta del remitente. De otra forma, devuelve un error.</li>
  <li>Calcula la comisión de la transacción como <code class="highlighter-rouge">STARTGAS * GASPRICE</code>, y determina la dirección de remisión a partir de la firma. Sustrae la comisión desde el balance de la cuenta del remitente y aumenta el nonce del remitente. Si no hay balance suficiente para gastar, devuelve un error.</li>
  <li>Inicia <code class="highlighter-rouge">GAS = STARTGAS</code> y retira cierta cantidad de gas por byte para pagar los bytes de la transacción.</li>
  <li>Transfiere el valor de la transacción desde la cuenta del remitente a la cuenta del destinatario. Si la cuenta del destinatario no existe todavía, la crea. Si la cuenta del destinatario es un contrato, ejecuta el código del contrato hasta completarlo o hasta que la ejecución consuma todo el gas.</li>
  <li>Si transferencia de valor falla porque el remitente carecía de suficiente dinero o porque la ejecución del código consumió todo el gas, revierte todos los cambios en el estado excepto el pago de las comisiones y agrega las comisiones a la cuenta del minero.</li>
  <li>De otra forma, reembolsa las comisiones correspondientes a los gas que sobraron al remitente y envia las comisiones de los gas consumidos al minero.</li>
</ol>

<p>Por ejemplo, supongamos que el código del contrato es:</p>

<figure class="highlight"><pre><code class="language-serpent" data-lang="serpent">if !self.storage[calldataload(0)]:
    self.storage[calldataload(0)] = calldataload(32)</code></pre></figure>

<p>Hay que anotar que en realidad el código del contrato está escrito en código de EVM de bajo nivel; el ejemplo mostrado está escrito en Serpent, uno de nuestros lenguajes de alto nivel, a modo de ilustración, y pude ser compilado a código EVM. Suponga que el almacenamiento del contrato inicia vacío y se envía una transacción con un valor de 10 ether, 2000 gas, 0.0001 ether de gasprice y 64 bytes de datos con los bytes 0-31 que representan el número <code class="highlighter-rouge">2</code> y los bytes 32-63 que corresponden a la cadena <code class="highlighter-rouge">CHARLIE</code>. El proceso para la función de transición de estado es como sigue:</p>

<ol>
  <li>Revisa que la transacción es válida y bien formada.</li>
  <li>Revisa que el remitente de la transacción posee por lo menos 2000 * 0.001 ether. Si es así, sustrae 2 ether de la cuenta del remitente.</li>
  <li>Inicializa gas = 2000; al asumir que la transacción es de 170 bytes y que la comisión por byte es de 5, resta 850 de modo que quedan 1150 gas.</li>
  <li>Retira 10 ether más de la cuenta del remitente y los agrega a la cuenta del contrato.</li>
  <li>Ejecuta el código. En este caso, es muy simple: revisa si se usa el almacenamiento del contrato en el índice 2, nota que no es así, así que asigna al almacenamiento en el índice 2 el valor <code class="highlighter-rouge">CHARLIE</code>. Suponga que esto toma 187 gas. El resto del gas es 1150 - 187 = 963.</li>
  <li>Regresa 963*0.001 ether a la cuenta del remitente y devuelve el estado resultante.</li>
</ol>

<p>Nótese que los mensajes funcionan de forma equivalente a transacciones en términos de capacidad de revertir: si la ejecución de un mensaje agota el gas, entonces esa ejecución y todas las ejecuciones desencadenadas por ella se revierten, pero las ejecucuines anteriores no tienen por que hacer esto. Esto quiere decir que es “seguro” para un contrato llamar a otro contrato debido a que si A invoca a B con G cantidad de gas, entonces se garantiza que la ejecución de A pierde a lo mucho G gas. Finalmente, nótese que hay un código operacional, <code class="highlighter-rouge">CREATE</code>, que que crea un contrato; la mecánica de su ejecución es generalemnte similar a <code class="highlighter-rouge">CALL</code> con la excepción de que la salida de la ejecución determina el código de un contrato recién creado.</p>

<h3 id="ejecucin-de-cdigo">Ejecución de Código</h3>

<p>El código en los contratos Ethereum está escrito en un lenguaje bytecode de bajo nivel basado en stacks, conocido como “código de máquina virtual de Ethereum” o “código EVM”. El código compone de una serie de bytes donde cada byte representa una operación. En general, la ejecución de código es un bucle infinito que consiste en llevar a cabo de forma repetitiva la operación en el contador actual del programa (que comienza en cero) y luego incrementando este contador unitariamente hasta alcanzar el final del código o hasta detectar una instrucción <code class="highlighter-rouge">STOP</code> o <code class="highlighter-rouge">RETURN</code>. Las operaciones tienen acceso a a tres tipos de espacio en donde almacenar los datos:</p>

<ul>
  <li>El <strong>stack</strong>, un contenedor de tipo entra-último-sale-primero donde se ingresan y se retiran los valores</li>
  <li>La <strong>memoria</strong>, una arreglo de bytes que se puede expandir infinitamente</li>
  <li>El <strong>almacenamiento</strong> a largo plazo del contrato de tipo clave/valor. A diferencia del stack y la memoria que se reinician cuando se termina el cálculo, el almacenamiento persiste a largo plazo.</li>
</ul>

<p>El código pude acceder al valor, remitente y datos del mensaje entrante, al igual que a los datos de la cabecera del bloque, y el código puede también retornar un arreglo de bytes de datos como salida.</p>

<p>El modelo de ejecución formal del código EVM es sorprendentemente simple. Mientras la máquina virtual Ethereum está corriendo, su estado computacional completo se puede definir por la tupla <code class="highlighter-rouge">(block_state, transaction, message, code, memory, stack, pc, gas)</code>; aquí <code class="highlighter-rouge">block_state</code> es el estado global que contiene todas las cuentas, incluyendo los balances y el almacenamiento. Al comienzo de cada ronda de ejecución, la instrucción actual se encuentra tomando el byte <code class="highlighter-rouge">pc</code>-ésimo del <code class="highlighter-rouge">code</code> (ó 0 si <code class="highlighter-rouge">pc &gt;= len(code)</code>), y cada instrucción tiene su propia definición de acuerdo a su efecto en la tupla. Por ejemplo, <code class="highlighter-rouge">ADD</code> retira dos elementos del stack e ingresa su suma, reduce el <code class="highlighter-rouge">gas</code> en una unidad e incrementa <code class="highlighter-rouge">pc</code> en una unidad, luego <code class="highlighter-rouge">SSTORE</code> retira dos elementos del stack e inserta el segundo objeto en el almacenamiento del contrato en el índice especificado por el primer objeto. Aunque hay muchas formas de optimizar la ejecución de la máquina virtual de Ethereum a través de compilación <em>just-in-time</em>, se puede hacer una implementación básica de Ethereum en unos cuantos cientos de líneas de código.</p>

<h3 id="blockchain-y-minera">Blockchain y Minería</h3>

<p><img src="https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/apply_block_diagram.png" alt="diagrama de bloques" /></p>

<p>El blockchain de Ethereum es en esencia muy similar al de Bitcoin, aunque tiene algunas diferencias. La principal diferencia entre Ethereum y Bitcoin con respecto a la arquitectura blockchain es que a diferencia de Bitcoin (que sólo contiene una copia de la lista de transacciones), los bloques de Ethereum contienen una copia tanto de la lista de transacciones como del estado más reciente. Aparte de eso, otros dos valores, el número del bloque y la dificultad, también se almacenan en el bloque. El algoritmo básico de validación de Ethereum es así:</p>

<ol>
  <li>Revisar si el bloque previo referenciado existe y es válido.</li>
  <li>Revisar que la marca cronológica del bloque es mayor que la del bloque previo referenciado y menor que 15 minutos en el futuro.</li>
  <li>Revisar que el número del bloque, la dificultad, la raíz de la transacción, la raíz “tío” y el límite de gas (conceptos de bajo nivel específicos a Ethereum) son válidos.</li>
  <li>Revisar que la prueba de trabajo en el bloque es válido.</li>
  <li>Asignar a <code class="highlighter-rouge">S[0]</code> el estado al final del bloque anterior.</li>
  <li>Asignar a <code class="highlighter-rouge">TX</code> la lista de transacciones del bloque, con <code class="highlighter-rouge">n</code> transacciones. Para todo <code class="highlighter-rouge">i</code> en <code class="highlighter-rouge">0...n-1</code>, establecer <code class="highlighter-rouge">S[i+1] = APPLY(S[i], TX[i])</code>. Si alguna aplicación retorna un error, o si el gas total consumido en el bloque hasta este punto excede el <code class="highlighter-rouge">GASLIMIT</code>, retornar un error.</li>
  <li>Asignar a <code class="highlighter-rouge">S_FINAL</code> el valor de <code class="highlighter-rouge">S[n]</code> pero agregando la recompensa del bloque al minero.</li>
  <li>Revisar si la raíz del árbol de Merkle del estado <code class="highlighter-rouge">S_FINAL</code> es igual a la raíz del estado final que aparece en la cabecera del bloque. Si es así, el bloque es válido; de otra forma, no es válido.</li>
</ol>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Bitcoin y Criptomonedas</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Bitcoin y Criptomonedas</li>
          <li><a href="mailto:lowenhard@yahoo.com">lowenhard@yahoo.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/leonardo384"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">leonardo384</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/Pythonista100"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">Pythonista100</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Mis opiniones e investigaciones acerca del mundo de Bitcoin, Blockchain y criptomonedas que serán el futuro de la Internet del dinero</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
